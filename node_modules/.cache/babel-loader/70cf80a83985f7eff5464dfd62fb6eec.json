{"ast":null,"code":";\n\n(function (exports) {\n  'use strict';\n\n  var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n  var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\n  var PLUS = '+'.charCodeAt(0);\n  var SLASH = '/'.charCodeAt(0);\n  var NUMBER = '0'.charCodeAt(0);\n  var LOWER = 'a'.charCodeAt(0);\n  var UPPER = 'A'.charCodeAt(0);\n  var PLUS_URL_SAFE = '-'.charCodeAt(0);\n  var SLASH_URL_SAFE = '_'.charCodeAt(0);\n\n  function decode(elt) {\n    var code = elt.charCodeAt(0);\n    if (code === PLUS || code === PLUS_URL_SAFE) return 62; // '+'\n\n    if (code === SLASH || code === SLASH_URL_SAFE) return 63; // '/'\n\n    if (code < NUMBER) return -1; // no match\n\n    if (code < NUMBER + 10) return code - NUMBER + 26 + 26;\n    if (code < UPPER + 26) return code - UPPER;\n    if (code < LOWER + 26) return code - LOWER + 26;\n  }\n\n  function b64ToByteArray(b64) {\n    var i, j, l, tmp, placeHolders, arr;\n\n    if (b64.length % 4 > 0) {\n      throw new Error('Invalid string. Length must be a multiple of 4');\n    } // the number of equal signs (place holders)\n    // if there are two placeholders, than the two characters before it\n    // represent one byte\n    // if there is only one, then the three characters before it represent 2 bytes\n    // this is just a cheap hack to not do indexOf twice\n\n\n    var len = b64.length;\n    placeHolders = b64.charAt(len - 2) === '=' ? 2 : b64.charAt(len - 1) === '=' ? 1 : 0; // base64 is 4/3 + up to two characters of the original data\n\n    arr = new Arr(b64.length * 3 / 4 - placeHolders); // if there are placeholders, only get up to the last complete 4 chars\n\n    l = placeHolders > 0 ? b64.length - 4 : b64.length;\n    var L = 0;\n\n    function push(v) {\n      arr[L++] = v;\n    }\n\n    for (i = 0, j = 0; i < l; i += 4, j += 3) {\n      tmp = decode(b64.charAt(i)) << 18 | decode(b64.charAt(i + 1)) << 12 | decode(b64.charAt(i + 2)) << 6 | decode(b64.charAt(i + 3));\n      push((tmp & 0xFF0000) >> 16);\n      push((tmp & 0xFF00) >> 8);\n      push(tmp & 0xFF);\n    }\n\n    if (placeHolders === 2) {\n      tmp = decode(b64.charAt(i)) << 2 | decode(b64.charAt(i + 1)) >> 4;\n      push(tmp & 0xFF);\n    } else if (placeHolders === 1) {\n      tmp = decode(b64.charAt(i)) << 10 | decode(b64.charAt(i + 1)) << 4 | decode(b64.charAt(i + 2)) >> 2;\n      push(tmp >> 8 & 0xFF);\n      push(tmp & 0xFF);\n    }\n\n    return arr;\n  }\n\n  function uint8ToBase64(uint8) {\n    var i;\n    var extraBytes = uint8.length % 3; // if we have 1 byte left, pad 2 bytes\n\n    var output = '';\n    var temp, length;\n\n    function encode(num) {\n      return lookup.charAt(num);\n    }\n\n    function tripletToBase64(num) {\n      return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F);\n    } // go through the array every three bytes, we'll deal with trailing stuff later\n\n\n    for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n      temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];\n      output += tripletToBase64(temp);\n    } // pad the end with zeros, but make sure to not forget the extra bytes\n\n\n    switch (extraBytes) {\n      case 1:\n        temp = uint8[uint8.length - 1];\n        output += encode(temp >> 2);\n        output += encode(temp << 4 & 0x3F);\n        output += '==';\n        break;\n\n      case 2:\n        temp = (uint8[uint8.length - 2] << 8) + uint8[uint8.length - 1];\n        output += encode(temp >> 10);\n        output += encode(temp >> 4 & 0x3F);\n        output += encode(temp << 2 & 0x3F);\n        output += '=';\n        break;\n\n      default:\n        break;\n    }\n\n    return output;\n  }\n\n  exports.toByteArray = b64ToByteArray;\n  exports.fromByteArray = uint8ToBase64;\n})(typeof exports === 'undefined' ? this.base64js = {} : exports);","map":{"version":3,"sources":["/Users/charleszhang/bruinbyte/node_modules/base64-js/lib/b64.js"],"names":["exports","lookup","Arr","Uint8Array","Array","PLUS","charCodeAt","SLASH","NUMBER","LOWER","UPPER","PLUS_URL_SAFE","SLASH_URL_SAFE","decode","elt","code","b64ToByteArray","b64","i","j","l","tmp","placeHolders","arr","length","Error","len","charAt","L","push","v","uint8ToBase64","uint8","extraBytes","output","temp","encode","num","tripletToBase64","toByteArray","fromByteArray","base64js"],"mappings":"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","sourcesContent":[";(function (exports) {\n  'use strict'\n\n  var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n\n  var Arr = (typeof Uint8Array !== 'undefined')\n    ? Uint8Array\n    : Array\n\n  var PLUS = '+'.charCodeAt(0)\n  var SLASH = '/'.charCodeAt(0)\n  var NUMBER = '0'.charCodeAt(0)\n  var LOWER = 'a'.charCodeAt(0)\n  var UPPER = 'A'.charCodeAt(0)\n  var PLUS_URL_SAFE = '-'.charCodeAt(0)\n  var SLASH_URL_SAFE = '_'.charCodeAt(0)\n\n  function decode (elt) {\n    var code = elt.charCodeAt(0)\n    if (code === PLUS || code === PLUS_URL_SAFE) return 62 // '+'\n    if (code === SLASH || code === SLASH_URL_SAFE) return 63 // '/'\n    if (code < NUMBER) return -1 // no match\n    if (code < NUMBER + 10) return code - NUMBER + 26 + 26\n    if (code < UPPER + 26) return code - UPPER\n    if (code < LOWER + 26) return code - LOWER + 26\n  }\n\n  function b64ToByteArray (b64) {\n    var i, j, l, tmp, placeHolders, arr\n\n    if (b64.length % 4 > 0) {\n      throw new Error('Invalid string. Length must be a multiple of 4')\n    }\n\n    // the number of equal signs (place holders)\n    // if there are two placeholders, than the two characters before it\n    // represent one byte\n    // if there is only one, then the three characters before it represent 2 bytes\n    // this is just a cheap hack to not do indexOf twice\n    var len = b64.length\n    placeHolders = b64.charAt(len - 2) === '=' ? 2 : b64.charAt(len - 1) === '=' ? 1 : 0\n\n    // base64 is 4/3 + up to two characters of the original data\n    arr = new Arr(b64.length * 3 / 4 - placeHolders)\n\n    // if there are placeholders, only get up to the last complete 4 chars\n    l = placeHolders > 0 ? b64.length - 4 : b64.length\n\n    var L = 0\n\n    function push (v) {\n      arr[L++] = v\n    }\n\n    for (i = 0, j = 0; i < l; i += 4, j += 3) {\n      tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))\n      push((tmp & 0xFF0000) >> 16)\n      push((tmp & 0xFF00) >> 8)\n      push(tmp & 0xFF)\n    }\n\n    if (placeHolders === 2) {\n      tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)\n      push(tmp & 0xFF)\n    } else if (placeHolders === 1) {\n      tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)\n      push((tmp >> 8) & 0xFF)\n      push(tmp & 0xFF)\n    }\n\n    return arr\n  }\n\n  function uint8ToBase64 (uint8) {\n    var i\n    var extraBytes = uint8.length % 3 // if we have 1 byte left, pad 2 bytes\n    var output = ''\n    var temp, length\n\n    function encode (num) {\n      return lookup.charAt(num)\n    }\n\n    function tripletToBase64 (num) {\n      return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)\n    }\n\n    // go through the array every three bytes, we'll deal with trailing stuff later\n    for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n      temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n      output += tripletToBase64(temp)\n    }\n\n    // pad the end with zeros, but make sure to not forget the extra bytes\n    switch (extraBytes) {\n      case 1:\n        temp = uint8[uint8.length - 1]\n        output += encode(temp >> 2)\n        output += encode((temp << 4) & 0x3F)\n        output += '=='\n        break\n      case 2:\n        temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])\n        output += encode(temp >> 10)\n        output += encode((temp >> 4) & 0x3F)\n        output += encode((temp << 2) & 0x3F)\n        output += '='\n        break\n      default:\n        break\n    }\n\n    return output\n  }\n\n  exports.toByteArray = b64ToByteArray\n  exports.fromByteArray = uint8ToBase64\n}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))\n"]},"metadata":{},"sourceType":"script"}